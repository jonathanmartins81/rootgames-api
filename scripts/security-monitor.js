#!/usr/bin/env node

/**
 * Script de Monitoramento de Seguran√ßa para RootGames API
 *
 * Funcionalidades:
 * - Verifica√ß√£o de vulnerabilidades
 * - Monitoramento de logs de seguran√ßa
 * - Alertas autom√°ticos
 * - Relat√≥rios de seguran√ßa
 */

const fs = require('fs');
const path = require('path');
const axios = require('axios');
const { execSync } = require('child_process');

class SecurityMonitor {
  constructor() {
    this.config = {
      apiBase: 'http://localhost:1337',
      logFile: path.join(process.cwd(), 'logs', 'security.log'),
      alertThresholds: {
        errorRate: 0.1, // 10%
        responseTime: 5000, // 5 segundos
        failedLogins: 5, // por minuto
        suspiciousRequests: 10 // por minuto
      }
    };

    this.metrics = {
      totalRequests: 0,
      errorRequests: 0,
      suspiciousRequests: 0,
      failedLogins: 0,
      uploadAttempts: 0,
      startTime: Date.now()
    };

    this.alerts = [];
  }

  async initialize() {
    console.log('üîí INICIANDO MONITOR DE SEGURAN√áA ROOTGAMES');
    console.log('============================================');

    // Criar diret√≥rio de logs se n√£o existir
    const logDir = path.dirname(this.config.logFile);
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }

    // Verificar se o servidor est√° rodando
    await this.checkServerHealth();

    // Iniciar monitoramento
    this.startMonitoring();
  }

  async checkServerHealth() {
    try {
      const response = await axios.get(`${this.config.apiBase}/api/games?pagination%5BpageSize%5D=1`, {
        timeout: 5000
      });

      if (response.status === 200) {
        console.log('‚úÖ Servidor Strapi est√° funcionando');
        return true;
      }
    } catch (error) {
      console.log('‚ùå Servidor Strapi n√£o est√° respondendo');
      console.log('   Erro:', error.message);
      return false;
    }
  }

  startMonitoring() {
    console.log('üìä Iniciando monitoramento de seguran√ßa...');

    // Verificar vulnerabilidades a cada 6 horas
    setInterval(() => {
      this.checkVulnerabilities();
    }, 6 * 60 * 60 * 1000);

    // Verificar logs de seguran√ßa a cada minuto
    setInterval(() => {
      this.analyzeSecurityLogs();
    }, 60 * 1000);

    // Gerar relat√≥rio di√°rio
    setInterval(() => {
      this.generateDailyReport();
    }, 24 * 60 * 60 * 1000);

    // Verifica√ß√£o inicial
    this.checkVulnerabilities();
    this.analyzeSecurityLogs();

    console.log('‚úÖ Monitor de seguran√ßa ativo');
  }

  async checkVulnerabilities() {
    console.log('üîç Verificando vulnerabilidades...');

    try {
      // Executar yarn audit
      const auditResult = execSync('yarn audit --json', {
        encoding: 'utf8',
        cwd: process.cwd()
      });

      const vulnerabilities = this.parseAuditResults(auditResult);

      if (vulnerabilities.length > 0) {
        console.log(`‚ö†Ô∏è  ${vulnerabilities.length} vulnerabilidades encontradas`);

        // Filtrar vulnerabilidades cr√≠ticas e altas
        const criticalVulns = vulnerabilities.filter(v => v.severity === 'critical' || v.severity === 'high');

        if (criticalVulns.length > 0) {
          this.createAlert('CRITICAL', `Encontradas ${criticalVulns.length} vulnerabilidades cr√≠ticas/altas`, {
            vulnerabilities: criticalVulns
          });
        }

        // Salvar relat√≥rio de vulnerabilidades
        this.saveVulnerabilityReport(vulnerabilities);
      } else {
        console.log('‚úÖ Nenhuma vulnerabilidade encontrada');
      }

    } catch (error) {
      console.log('‚ùå Erro ao verificar vulnerabilidades:', error.message);
    }
  }

  parseAuditResults(auditOutput) {
    const vulnerabilities = [];
    const lines = auditOutput.split('\n');

    lines.forEach(line => {
      try {
        const data = JSON.parse(line);
        if (data.type === 'auditAdvisory') {
          vulnerabilities.push({
            severity: data.data.severity,
            package: data.data.module_name,
            title: data.data.title,
            description: data.data.overview,
            recommendation: data.data.recommendation,
            url: data.data.url
          });
        }
      } catch (e) {
        // Ignorar linhas que n√£o s√£o JSON v√°lido
      }
    });

    return vulnerabilities;
  }

  analyzeSecurityLogs() {
    if (!fs.existsSync(this.config.logFile)) {
      return;
    }

    try {
      const logContent = fs.readFileSync(this.config.logFile, 'utf8');
      const lines = logContent.split('\n').filter(line => line.trim());

      // Analisar √∫ltimas 100 linhas
      const recentLines = lines.slice(-100);

      recentLines.forEach(line => {
        this.analyzeLogLine(line);
      });

      // Verificar alertas
      this.checkAlertThresholds();

    } catch (error) {
      console.log('‚ùå Erro ao analisar logs:', error.message);
    }
  }

  analyzeLogLine(line) {
    this.metrics.totalRequests++;

    // Detectar erros
    if (line.includes('ERROR') || line.includes('error')) {
      this.metrics.errorRequests++;
    }

    // Detectar tentativas de login falhadas
    if (line.includes('authentication_failure') || line.includes('invalid_api_key')) {
      this.metrics.failedLogins++;
    }

    // Detectar requisi√ß√µes suspeitas
    if (line.includes('suspicious') || line.includes('rate_limit_exceeded')) {
      this.metrics.suspiciousRequests++;
    }

    // Detectar tentativas de upload
    if (line.includes('upload_attempt')) {
      this.metrics.uploadAttempts++;
    }
  }

  checkAlertThresholds() {
    const now = Date.now();
    const timeWindow = 60 * 1000; // 1 minuto
    const recentTime = now - timeWindow;

    // Calcular taxa de erro
    const errorRate = this.metrics.totalRequests > 0
      ? this.metrics.errorRequests / this.metrics.totalRequests
      : 0;

    // Verificar alertas
    if (errorRate > this.config.alertThresholds.errorRate) {
      this.createAlert('HIGH', `Taxa de erro alta: ${(errorRate * 100).toFixed(1)}%`);
    }

    if (this.metrics.failedLogins > this.config.alertThresholds.failedLogins) {
      this.createAlert('HIGH', `Muitas tentativas de login falhadas: ${this.metrics.failedLogins}`);
    }

    if (this.metrics.suspiciousRequests > this.config.alertThresholds.suspiciousRequests) {
      this.createAlert('MEDIUM', `Muitas requisi√ß√µes suspeitas: ${this.metrics.suspiciousRequests}`);
    }
  }

  createAlert(level, message, data = {}) {
    const alert = {
      timestamp: new Date().toISOString(),
      level,
      message,
      data,
      id: Date.now()
    };

    this.alerts.push(alert);

    console.log(`üö® ALERTA ${level}: ${message}`);

    // Salvar alerta em arquivo
    this.saveAlert(alert);

    // Em produ√ß√£o, enviar notifica√ß√£o (email, Slack, etc.)
    if (level === 'CRITICAL' || level === 'HIGH') {
      this.sendNotification(alert);
    }
  }

  saveAlert(alert) {
    const alertFile = path.join(process.cwd(), 'logs', 'alerts.json');
    let alerts = [];

    if (fs.existsSync(alertFile)) {
      try {
        alerts = JSON.parse(fs.readFileSync(alertFile, 'utf8'));
      } catch (e) {
        alerts = [];
      }
    }

    alerts.push(alert);

    // Manter apenas √∫ltimos 1000 alertas
    if (alerts.length > 1000) {
      alerts = alerts.slice(-1000);
    }

    fs.writeFileSync(alertFile, JSON.stringify(alerts, null, 2));
  }

  saveVulnerabilityReport(vulnerabilities) {
    const reportFile = path.join(process.cwd(), 'logs', 'vulnerabilities.json');
    const report = {
      timestamp: new Date().toISOString(),
      total: vulnerabilities.length,
      critical: vulnerabilities.filter(v => v.severity === 'critical').length,
      high: vulnerabilities.filter(v => v.severity === 'high').length,
      moderate: vulnerabilities.filter(v => v.severity === 'moderate').length,
      low: vulnerabilities.filter(v => v.severity === 'low').length,
      vulnerabilities
    };

    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
  }

  generateDailyReport() {
    const uptime = Date.now() - this.metrics.startTime;
    const uptimeHours = Math.floor(uptime / (1000 * 60 * 60));

    const report = {
      date: new Date().toISOString().split('T')[0],
      uptime: `${uptimeHours} horas`,
      metrics: {
        totalRequests: this.metrics.totalRequests,
        errorRequests: this.metrics.errorRequests,
        errorRate: this.metrics.totalRequests > 0
          ? (this.metrics.errorRequests / this.metrics.totalRequests * 100).toFixed(2) + '%'
          : '0%',
        suspiciousRequests: this.metrics.suspiciousRequests,
        failedLogins: this.metrics.failedLogins,
        uploadAttempts: this.metrics.uploadAttempts
      },
      alerts: this.alerts.length,
      recommendations: this.generateRecommendations()
    };

    const reportFile = path.join(process.cwd(), 'logs', `security-report-${report.date}.json`);
    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));

    console.log(`üìä Relat√≥rio di√°rio gerado: ${reportFile}`);

    // Resetar m√©tricas para o pr√≥ximo dia
    this.resetMetrics();
  }

  generateRecommendations() {
    const recommendations = [];

    if (this.metrics.errorRequests > this.metrics.totalRequests * 0.05) {
      recommendations.push('Investigar causa dos erros elevados');
    }

    if (this.metrics.failedLogins > 10) {
      recommendations.push('Implementar bloqueio de IP ap√≥s tentativas falhadas');
    }

    if (this.metrics.suspiciousRequests > 5) {
      recommendations.push('Revisar logs de requisi√ß√µes suspeitas');
    }

    if (this.alerts.length > 20) {
      recommendations.push('Revisar configura√ß√µes de alertas');
    }

    return recommendations;
  }

  resetMetrics() {
    this.metrics = {
      totalRequests: 0,
      errorRequests: 0,
      suspiciousRequests: 0,
      failedLogins: 0,
      uploadAttempts: 0,
      startTime: Date.now()
    };
    this.alerts = [];
  }

  sendNotification(alert) {
    // Em produ√ß√£o, implementar envio de notifica√ß√µes
    console.log(`üìß NOTIFICA√á√ÉO: ${alert.level} - ${alert.message}`);
  }

  // M√©todo para parar o monitoramento
  stop() {
    console.log('üõë Parando monitor de seguran√ßa...');
    process.exit(0);
  }
}

// Executar se chamado diretamente
if (require.main === module) {
  const monitor = new SecurityMonitor();

  // Tratar sinais de parada
  process.on('SIGINT', () => {
    monitor.stop();
  });

  process.on('SIGTERM', () => {
    monitor.stop();
  });

  monitor.initialize().catch(console.error);
}

module.exports = SecurityMonitor;
