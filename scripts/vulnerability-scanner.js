#!/usr/bin/env node

/**
 * Scanner de Vulnerabilidades para RootGames API
 *
 * Funcionalidades:
 * - Verifica√ß√£o autom√°tica de vulnerabilidades
 * - An√°lise de depend√™ncias
 * - Relat√≥rios detalhados
 * - Integra√ß√£o com CI/CD
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const axios = require('axios');

class VulnerabilityScanner {
  constructor() {
    this.projectRoot = process.cwd();
    this.logsDir = path.join(this.projectRoot, 'logs');
    this.reportsDir = path.join(this.logsDir, 'reports');
    this.config = {
      // Configura√ß√µes de verifica√ß√£o
      checkInterval: 6 * 60 * 60 * 1000, // 6 horas
      maxRetries: 3,
      timeout: 30000, // 30 segundos

      // N√≠veis de severidade para alertar
      alertLevels: ['critical', 'high'],

      // APIs de verifica√ß√£o de vulnerabilidades
      apis: {
        npm: 'https://registry.npmjs.org',
        yarn: 'https://yarnpkg.com',
        snyk: 'https://snyk.io/api/v1'
      }
    };

    this.results = {
      lastScan: null,
      totalVulnerabilities: 0,
      criticalVulnerabilities: 0,
      highVulnerabilities: 0,
      moderateVulnerabilities: 0,
      lowVulnerabilities: 0,
      vulnerabilities: []
    };
  }

  async scan() {
    console.log('üîç INICIANDO SCAN DE VULNERABILIDADES');
    console.log('=====================================');

    try {
      // 1. Verificar depend√™ncias do package.json
      await this.scanPackageJson();

      // 2. Executar yarn audit
      await this.runYarnAudit();

      // 3. Verificar depend√™ncias desatualizadas
      await this.checkOutdatedPackages();

      // 4. Verificar licen√ßas
      await this.checkLicenses();

      // 5. Gerar relat√≥rio
      await this.generateReport();

      // 6. Enviar alertas se necess√°rio
      await this.sendAlerts();

      console.log('‚úÖ Scan de vulnerabilidades conclu√≠do');

    } catch (error) {
      console.error('‚ùå Erro durante o scan:', error.message);
      throw error;
    }
  }

  async scanPackageJson() {
    console.log('üì¶ Analisando package.json...');

    const packageJsonPath = path.join(this.projectRoot, 'package.json');
    if (!fs.existsSync(packageJsonPath)) {
      throw new Error('package.json n√£o encontrado');
    }

    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    const dependencies = {
      ...packageJson.dependencies || {},
      ...packageJson.devDependencies || {}
    };

    console.log(`   üìä ${Object.keys(dependencies).length} depend√™ncias encontradas`);

    // Verificar depend√™ncias conhecidas por serem vulner√°veis
    const knownVulnerablePackages = [
      'axios@<1.12.0',
      'koa@<2.15.4',
      'sharp@<0.32.6',
      'braces@<3.0.3',
      'ws@<8.17.1',
      'tar@<6.2.1'
    ];

    for (const [name, version] of Object.entries(dependencies)) {
      const vulnerablePackage = knownVulnerablePackages.find(pkg =>
        pkg.startsWith(name + '@')
      );

      if (vulnerablePackage) {
        const [, minVersion] = vulnerablePackage.split('@');
        this.addVulnerability({
          package: name,
          currentVersion: version,
          severity: 'high',
          title: `Depend√™ncia vulner√°vel: ${name}`,
          description: `Vers√£o ${version} √© vulner√°vel. M√≠nimo recomendado: ${minVersion}`,
          recommendation: `Atualize para vers√£o ${minVersion} ou superior`,
          source: 'package.json analysis'
        });
      }
    }
  }

  async runYarnAudit() {
    console.log('üîç Executando yarn audit...');

    try {
      const auditOutput = execSync('yarn audit --json', {
        encoding: 'utf8',
        cwd: this.projectRoot,
        timeout: this.config.timeout
      });

      const vulnerabilities = this.parseYarnAudit(auditOutput);

      vulnerabilities.forEach(vuln => {
        this.addVulnerability({
          package: vuln.package,
          currentVersion: vuln.currentVersion,
          severity: vuln.severity,
          title: vuln.title,
          description: vuln.description,
          recommendation: vuln.recommendation,
          url: vuln.url,
          source: 'yarn audit'
        });
      });

      console.log(`   üìä ${vulnerabilities.length} vulnerabilidades encontradas pelo yarn audit`);

    } catch (error) {
      if (error.status === 0) {
        console.log('   ‚úÖ Nenhuma vulnerabilidade encontrada pelo yarn audit');
      } else {
        console.log('   ‚ö†Ô∏è  Erro no yarn audit:', error.message);
      }
    }
  }

  parseYarnAudit(auditOutput) {
    const vulnerabilities = [];
    const lines = auditOutput.split('\n');

    lines.forEach(line => {
      try {
        const data = JSON.parse(line);
        if (data.type === 'auditAdvisory') {
          vulnerabilities.push({
            package: data.data.module_name,
            currentVersion: data.data.findings?.[0]?.version || 'unknown',
            severity: data.data.severity,
            title: data.data.title,
            description: data.data.overview,
            recommendation: data.data.recommendation,
            url: data.data.url
          });
        }
      } catch (e) {
        // Ignorar linhas que n√£o s√£o JSON v√°lido
      }
    });

    return vulnerabilities;
  }

  async checkOutdatedPackages() {
    console.log('üîÑ Verificando pacotes desatualizados...');

    try {
      const outdatedOutput = execSync('yarn outdated --json', {
        encoding: 'utf8',
        cwd: this.projectRoot,
        timeout: this.config.timeout
      });

      const outdatedPackages = this.parseYarnOutdated(outdatedOutput);

      // Verificar se h√° atualiza√ß√µes de seguran√ßa dispon√≠veis
      outdatedPackages.forEach(pkg => {
        if (this.isSecurityUpdate(pkg)) {
          this.addVulnerability({
            package: pkg.name,
            currentVersion: pkg.current,
            severity: 'moderate',
            title: `Atualiza√ß√£o de seguran√ßa dispon√≠vel: ${pkg.name}`,
            description: `Vers√£o ${pkg.current} tem atualiza√ß√µes de seguran√ßa dispon√≠veis`,
            recommendation: `Atualize para vers√£o ${pkg.latest}`,
            source: 'outdated packages'
          });
        }
      });

      console.log(`   üìä ${outdatedPackages.length} pacotes desatualizados encontrados`);

    } catch (error) {
      console.log('   ‚ö†Ô∏è  Erro ao verificar pacotes desatualizados:', error.message);
    }
  }

  parseYarnOutdated(output) {
    const packages = [];
    const lines = output.split('\n');

    lines.forEach(line => {
      try {
        const data = JSON.parse(line);
        if (data.type === 'table' && data.data) {
          data.data.body.forEach(row => {
            packages.push({
              name: row[0],
              current: row[1],
              latest: row[2],
              type: row[3]
            });
          });
        }
      } catch (e) {
        // Ignorar linhas que n√£o s√£o JSON v√°lido
      }
    });

    return packages;
  }

  isSecurityUpdate(pkg) {
    // Verificar se a atualiza√ß√£o √© de seguran√ßa
    // Esta √© uma implementa√ß√£o simplificada
    const securityKeywords = ['security', 'vulnerability', 'cve', 'fix'];
    return securityKeywords.some(keyword =>
      pkg.name.toLowerCase().includes(keyword) ||
      pkg.type === 'dependencies'
    );
  }

  async checkLicenses() {
    console.log('üìÑ Verificando licen√ßas...');

    try {
      const licenseOutput = execSync('yarn licenses list --json', {
        encoding: 'utf8',
        cwd: this.projectRoot,
        timeout: this.config.timeout
      });

      const licenses = this.parseYarnLicenses(licenseOutput);

      // Verificar licen√ßas problem√°ticas
      const problematicLicenses = ['GPL-3.0', 'AGPL-3.0', 'LGPL-3.0'];

      licenses.forEach(license => {
        if (problematicLicenses.includes(license.license)) {
          this.addVulnerability({
            package: license.name,
            currentVersion: license.version,
            severity: 'low',
            title: `Licen√ßa problem√°tica: ${license.name}`,
            description: `Pacote ${license.name} usa licen√ßa ${license.license}`,
            recommendation: 'Considere substituir por alternativa com licen√ßa mais permissiva',
            source: 'license check'
          });
        }
      });

      console.log(`   üìä ${licenses.length} licen√ßas verificadas`);

    } catch (error) {
      console.log('   ‚ö†Ô∏è  Erro ao verificar licen√ßas:', error.message);
    }
  }

  parseYarnLicenses(output) {
    const licenses = [];
    const lines = output.split('\n');

    lines.forEach(line => {
      try {
        const data = JSON.parse(line);
        if (data.type === 'table' && data.data) {
          data.data.body.forEach(row => {
            licenses.push({
              name: row[0],
              version: row[1],
              license: row[2]
            });
          });
        }
      } catch (e) {
        // Ignorar linhas que n√£o s√£o JSON v√°lido
      }
    });

    return licenses;
  }

  addVulnerability(vuln) {
    this.results.vulnerabilities.push({
      ...vuln,
      id: Date.now() + Math.random(),
      timestamp: new Date().toISOString()
    });

    this.results.totalVulnerabilities++;

    switch (vuln.severity) {
      case 'critical':
        this.results.criticalVulnerabilities++;
        break;
      case 'high':
        this.results.highVulnerabilities++;
        break;
      case 'moderate':
        this.results.moderateVulnerabilities++;
        break;
      case 'low':
        this.results.lowVulnerabilities++;
        break;
    }
  }

  async generateReport() {
    console.log('üìä Gerando relat√≥rio de vulnerabilidades...');

    this.results.lastScan = new Date().toISOString();

    const report = {
      ...this.results,
      summary: {
        total: this.results.totalVulnerabilities,
        critical: this.results.criticalVulnerabilities,
        high: this.results.highVulnerabilities,
        moderate: this.results.moderateVulnerabilities,
        low: this.results.lowVulnerabilities,
        riskLevel: this.calculateRiskLevel()
      },
      recommendations: this.generateRecommendations(),
      nextScan: new Date(Date.now() + this.config.checkInterval).toISOString()
    };

    // Salvar relat√≥rio
    const reportFile = path.join(this.reportsDir, `vulnerability-report-${Date.now()}.json`);
    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));

    // Salvar relat√≥rio mais recente
    const latestReportFile = path.join(this.reportsDir, 'latest-vulnerability-report.json');
    fs.writeFileSync(latestReportFile, JSON.stringify(report, null, 2));

    console.log(`   üìÑ Relat√≥rio salvo: ${reportFile}`);
    console.log(`   üìä Resumo: ${report.summary.total} vulnerabilidades (${report.summary.critical} cr√≠ticas, ${report.summary.high} altas)`);
  }

  calculateRiskLevel() {
    if (this.results.criticalVulnerabilities > 0) return 'CRITICAL';
    if (this.results.highVulnerabilities > 5) return 'HIGH';
    if (this.results.highVulnerabilities > 0 || this.results.moderateVulnerabilities > 10) return 'MEDIUM';
    if (this.results.moderateVulnerabilities > 0 || this.results.lowVulnerabilities > 20) return 'LOW';
    return 'MINIMAL';
  }

  generateRecommendations() {
    const recommendations = [];

    if (this.results.criticalVulnerabilities > 0) {
      recommendations.push('üö® URGENTE: Corrija vulnerabilidades cr√≠ticas imediatamente');
    }

    if (this.results.highVulnerabilities > 0) {
      recommendations.push('‚ö†Ô∏è  Priorize corre√ß√£o de vulnerabilidades altas');
    }

    if (this.results.moderateVulnerabilities > 5) {
      recommendations.push('üìã Planeje corre√ß√£o de vulnerabilidades moderadas');
    }

    recommendations.push('üîÑ Execute scans regulares de vulnerabilidades');
    recommendations.push('üì¶ Mantenha depend√™ncias atualizadas');
    recommendations.push('üîí Configure monitoramento cont√≠nuo de seguran√ßa');

    return recommendations;
  }

  async sendAlerts() {
    const criticalVulns = this.results.vulnerabilities.filter(v => v.severity === 'critical');
    const highVulns = this.results.vulnerabilities.filter(v => v.severity === 'high');

    if (criticalVulns.length > 0 || highVulns.length > 5) {
      console.log('üö® Enviando alertas de seguran√ßa...');

      // Em produ√ß√£o, implementar envio de notifica√ß√µes
      console.log(`   üìß ${criticalVulns.length} vulnerabilidades cr√≠ticas`);
      console.log(`   üìß ${highVulns.length} vulnerabilidades altas`);
    }
  }

  // M√©todo para executar scan cont√≠nuo
  startContinuousScan() {
    console.log('üîÑ Iniciando scan cont√≠nuo de vulnerabilidades...');

    // Executar scan inicial
    this.scan();

    // Agendar pr√≥ximos scans
    setInterval(() => {
      this.scan();
    }, this.config.checkInterval);
  }
}

// Executar se chamado diretamente
if (require.main === module) {
  const scanner = new VulnerabilityScanner();

  // Verificar argumentos da linha de comando
  const args = process.argv.slice(2);

  if (args.includes('--continuous')) {
    scanner.startContinuousScan();
  } else {
    scanner.scan().catch(console.error);
  }
}

module.exports = VulnerabilityScanner;
